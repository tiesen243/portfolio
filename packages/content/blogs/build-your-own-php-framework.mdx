---
title: Building a Minimal PHP Framework from Scratch
description: A hands-on guide to understanding how PHP frameworks work by building your own—from routing and controllers to dependency injection and application bootstrapping.
tags:
  - PHP
  - Framework
  - Web Development
  - Programming
publishedAt: 2025-12-28
---

Most PHP developers rely on powerful frameworks like Laravel or Symfony to ship features quickly. They handle routing, dependency injection, templating, database access, and much more—often with a single command.

But sooner or later, a question shows up:

> How do PHP frameworks actually work under the hood?

In this article, we’ll answer that question by building a minimal PHP framework from scratch.
Not to compete with Laravel—but to understand it.

You’ll implement the core concepts shared by almost every modern PHP framework:

- Handling HTTP requests and responses
- Defining routes and dispatching controllers
- Rendering views
- Managing dependencies
- Bootstrapping the application

By the end, you’ll have a lightweight, extensible foundation and a much clearer mental model of what frameworks really do.

## 1. Setting Up the Project

Let’s begin with a clean project and initialize Composer:

```bash
mkdir my-php-framework
cd my-php-framework
composer init
```

For modern frontend development, we’ll use Vite and Tailwind CSS:

```package-install
-d vite tailwindcss @tailwindcss/vite
```

Next, configure autoloading so PHP can resolve classes automatically:

```json title="composer.json"
{
  // ...other composer.json settings...
  "autoload": {
    "psr-4": {
      "App\\": "app/",
      "Core\\": "src/"
    }
  }
}
```

Install dependencies and generate the autoloader:

```bash
composer install
```

Now create the following directory structure:

```text
.
├── app
│   ├── Controller
│   ├── config.php
│   └── routes.php
├── public
│   ├── favicon.ico
│   └── index.php
├── resources
│   ├── css
│   ├── js
│   └── views
├── src
│   ├── Abstract
│   ├── Http
│   ├── Kernel
│   ├── Application.php
│   └── helpers.php
├── composer.json
├── package.json
└── vite.config.ts
```

This layout separates application code, framework core, public entry point, and assets, just like a real-world framework.

## 2. Building the Framework

### 2.1. Handling Requests and Responses

At the heart of every framework is the request–response cycle.

Instead of working directly with PHP superglobals, we wrap them in a `Request` object:

```php title="src/Http/Request.php"
<?php

declare(strict_types=1);

namespace Core\Http;

class Request
{
  private array $get;
  private array $post;
  private array $server;

  public function __construct(array $get = [], array $post = [], array $server = []) {
    $this->get = !empty($get) ? $get : $_GET;
    $this->post = !empty($post) ? $post : $_POST;
    $this->server = !empty($server) ? $server : $_SERVER;
  }

  public function method(): string {
    return $this->server['REQUEST_METHOD'] ?? 'GET';
  }

  public function uri(): string {
    return $this->server['REQUEST_URI'] ?? '/';
  }

  public function getQuery(string $key, $default = null) {
    return $this->get[$key] ?? $default;
  }

  public function getPost(string $key, $default = null) {
    return $this->post[$key] ?? $default;
  }

  public function getArgv(int $index, $default = null) {
    $argv = $this->server['argv'] ?? [];

    return $argv[$index] ?? $default;
  }
}
```

To send data back to the client, we introduce a `Response` class:

```php title="src/Http/Response.php"
<?php

declare(strict_types=1);

namespace Core\Http;

class Response
{
  public function __construct(
    private string $body = '',
    private int $statusCode = 200,
    private array $headers = [],
  ) {
  }

  public function send(): void {
    http_response_code($this->statusCode);
    foreach ($this->headers as $key => $value) {
      header("{$key}: {$value}");
    }
    echo $this->body;
  }

  public static function json(array $data, int $statusCode = 200, array $headers = []): self {
    $headers['Content-Type'] = 'application/json';
    $body = json_encode($data);

    return new self($body, $statusCode, $headers);
  }

  public static function redirect(string $url, int $statusCode = 302, array $headers = []): self {
    $headers['Location'] = $url;

    return new self('', $statusCode, $headers);
  }
}
```

This gives us a clean and consistent API for HTML, JSON, and redirects.

### 2.2. Controllers

Controllers coordinate request handling and response generation.

We define a base controller that provides shared utilities like rendering views, returning JSON, redirects, and flash messages:

```php title="src/Abstract/Controller.php"
<?php

declare(strict_types=1);

namespace Core\Abstract;

use App\Entity\User;
use Core\Http\{Request, Response};
use Core\Kernel\Database;

abstract class Controller
{
  protected \PDO $db;

  public function __construct(protected Request $request, private string $basePath) {
    $this->db = Database::getInstance();
  }

  protected function render(string $view, array $data = [], string $layout = 'main'): Response {
    if (isset($_SESSION['redirect_data'])) {
      $data = array_merge($data, $_SESSION['redirect_data']);
      unset($_SESSION['redirect_data']);
    }

    if (!file_exists($this->basePath.'/resources/views/app/'.$view.'.php')) {
      return new Response('View not found: '.$view, 400);
    }

    ob_start();
    extract($data);
    $flash = $this->getFlash();
    require $this->basePath.'/resources/views/app/'.$view.'.php';
    $content = ob_get_clean();

    ob_start();
    require $this->basePath.'/resources/views/layouts/'.$layout.'.php';
    $content = ob_get_clean();

    return new Response($content);
  }

  protected function json(array $data): Response {
    $response = Response::json($data);

    return $response;
  }

  protected function redirect(string $url, array $data = []): Response {
    if (!empty($data)) {
      $_SESSION['redirect_data'] = $data;
    }
    $response = Response::redirect($url);

    return $response;
  }

  protected function getFlash(): ?array {
    if (isset($_SESSION['flash'])) {
      $flash = $_SESSION['flash'];
      unset($_SESSION['flash']);

      return $flash;
    }

    return null;
  }

  /**
   * @param "default"|"success"|"error"|"info"|"warn" $type
   */
  protected function setFlash(string $type = 'default', string $message = ''): void {
    $_SESSION['flash'] = [
      'type' => $type,
      'message' => $message,
    ];
  }

  protected function isAuthenticated(): bool {
    return isset($_SESSION['user']);
  }

  protected function getUser(): ?User {
    return $_SESSION['user'] ?? null;
  }
}
```

This keeps application controllers small, readable, and focused on business logic.

### 2.3. Routing

Routing maps incoming requests to handlers.

Our router supports:

- HTTP method-based routing
- Controller actions
- Dynamic parameters like `/user/:id`

```php title="src/Kernel/Router.php"
<?php

declare(strict_types=1);

namespace Core\Kernel;

class Router
{
  private static $routes = [];

  /**
   * Register a GET route.
   *
   * @param callable|array $handler Handler function or [Controller, method]
   */
  public static function get(string $path, callable|array $handler): self {
    self::addRoute('GET', $path, $handler);

    return new self();
  }

  /**
   * Register a POST route.
   *
   * @param string         $path
   * @param callable|array $handler Handler function or [Controller, method]
   */
  public static function post($path, $handler): self {
    self::addRoute('POST', $path, $handler);

    return new self();
  }

  private static function addRoute($method, $path, $handler) {
    self::$routes[$method][$path] = $handler;
  }

  public static function getRoutes(): array {
    return self::$routes;
  }
}
```

Despite its simplicity, this router already behaves like those found in full frameworks.

### 2.4. Database Connection

We use PDO and wrap it in a small database manager:

```php title="src/Kernel/Database.php"
<?php

declare(strict_types=1);

namespace Core\Kernel;

class Database
{
  private static $instance;
  private \PDO $connection;

  private function __construct(array $config) {
    $dsn = "{$config['driver']}:host={$config['host']};port={$config['port']};dbname={$config['name']};charset=utf8mb4";
    $this->connection = new \PDO($dsn, $config['user'], $config['password']);
    $this->connection->setAttribute(\PDO::ATTR_ERRMODE, \PDO::ERRMODE_EXCEPTION);
  }

  public static function connect(array $config): static {
    if (null === self::$instance) {
      self::$instance = new self($config);
    }

    return self::$instance;
  }

  public static function getInstance(): \PDO {
    if (null === self::$instance) {
      throw new \Exception('Database instance not created. Call createInstance() first.');
    }

    return self::$instance->connection;
  }
}
```

This centralizes database access and ensures a single shared connection.

### 2.5. Dependency Injection Container

To avoid tight coupling, we implement a simple dependency injection container using PHP reflection:

```php title="src/Kernel/Container.php"
<?php

declare(strict_types=1);

namespace Core\Kernel;

class Container
{
  protected array $bindings = [];

  public function bind(string $abstract, string $concrete): void {
    $this->bindings[$abstract] = $concrete;
  }

  public function make(string $class, array $parameters = []) {
    if (isset($this->bindings[$class])) {
      $class = $this->bindings[$class];
    }

    $reflector = new \ReflectionClass($class);

    if (!$reflector->isInstantiable()) {
      throw new \Exception("Class {$class} is not instantiable");
    }

    $constructor = $reflector->getConstructor();

    if (!$constructor) {
      return new $class();
    }

    $params = $constructor->getParameters();
    $dependencies = $this->resolveParameters($params, $parameters);

    return $reflector->newInstanceArgs($dependencies);
  }

  public function call($instance, string $method, array $manual = []) {
    $reflector = new \ReflectionMethod($instance, $method);
    $params = $reflector->getParameters();
    $dependencies = $this->resolveParameters($params, $manual);

    return $reflector->invokeArgs($instance, $dependencies);
  }

  protected function resolveParameters(array $params, array $manual = []): array {
    $resolved = [];

    foreach ($params as $param) {
      $type = $param->getType();
      $name = $param->getName();

      if ($type && !$type->isBuiltin()) {
        $resolved[] = $this->make($type->getName());
      } elseif (isset($manual[$name])) {
        $resolved[] = $manual[$name];
      } elseif ($param->isDefaultValueAvailable()) {
        $resolved[] = $param->getDefaultValue();
      } else {
        throw new \Exception("Cannot resolve parameter {$name}");
      }
    }

    return $resolved;
  }
}
```

The container automatically resolves constructor dependencies and method parameters—one of the most important features of modern frameworks.

### 2.6. Application Bootstrapping

The `Application` class ties everything together:

```php title="src/Application.php"
<?php

declare(strict_types=1);

namespace Core;

use Core\Http\{Request,Response};
use Core\Kernel\{Container, Database, Router};

class Application
{
  private string $basePath;
  private array $config;

  protected Container $container;
  protected Request $request;

  public function __construct(string $basePath) {
    $this->basePath = rtrim($basePath, '/');

    $this->loadEnv();
    $this->config = getConfig();
    Database::connect($this->config['database']);
  }

  public function register(callable $callback): self {
    $this->container = new Container();
    call_user_func($callback, $this->container);

    return $this;
  }

  public function run(): void {
    require_once $this->basePath.'/app/routes.php';

    $this->request = new Request($_GET, $_POST, $_SERVER);
    $routes = Router::getRoutes();

    $method = $this->request->method();
    $uri = parse_url($this->request->uri(), PHP_URL_PATH);
    if ('/' !== $uri && '/' === substr($uri, -1)) {
      $uri = rtrim($uri, '/');
    }

    if (isset($routes[$method][$uri])) {
      $response = $this->dispatch($routes[$method][$uri]);
    } else {
      foreach ($routes[$method] as $routePattern => $handler) {
        $pattern = preg_replace('#:([\w]+)#', '(?P<$1>[^/]+)', $routePattern);
        $pattern = '#^'.$pattern.'$#';
        if (preg_match($pattern, $uri, $matches)) {
          $params = array_filter($matches, 'is_string', ARRAY_FILTER_USE_KEY);
          $response = $this->dispatch($handler, $params);
        }
      }
    }

    if (!$response instanceof Response) {
      $response = new Response($response);
    }
    $this->setCorsHeaders();
    $response->send();
  }

  private function dispatch(callable|array $handler, array $params = []): Response {
    $response = Response::json(['message' => 'Not Found'], 404);

    if (is_callable($handler)) {
      $response = call_user_func($handler, $this->request, ...array_values($params));
    } elseif (is_array($handler) && 2 === count($handler)) {
      if (!is_subclass_of($handler[0], Abstract\Controller::class)) {
        $response = Response::json(['message' => 'Controller Not Found'], 404);
      } else {
        $controller = $this->container->make($handler[0], [
          'request' => $this->request,
          'basePath' => $this->basePath,
        ]);

        if (!method_exists($controller, $handler[1])) {
          $response = Response::json(['message' => 'Method Not Found'], 404);
        } else {
          $response = $this->container->call($controller, $handler[1], $params);
        }
      }
    }

    return $response;
  }

  private function loadEnv(string $envPath = '.env'): void {
    $envFile = $this->basePath.DIRECTORY_SEPARATOR.$envPath;
    if (!file_exists($envFile)) {
      return;
    }

    $lines = file($envFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
    foreach ($lines as $line) {
      if (0 === strpos(trim($line), '#')) {
        continue;
      }
      list($key, $value) = explode('=', $line, 2);
      $key = trim($key);
      $value = trim($value, "\"'");
      if (!getenv($key)) {
        putenv("{$key}={$value}");
      }
    }
  }

  private function setCorsHeaders(): void {
    $corsConfig = $this->config['cors'] ?? [];
    $allowedOrigins = $corsConfig['allowed_origins'] ?? [];
    $allowedMethods = $corsConfig['allowed_methods'] ?? [];
    $allowedHeaders = $corsConfig['allowed_headers'] ?? [];
    $allowCredentials = $corsConfig['allow_credentials'] ?? false;

    header('Access-Control-Allow-Origin: '.implode(',', $allowedOrigins));
    header('Access-Control-Allow-Methods: '.implode(',', $allowedMethods));
    header('Access-Control-Allow-Headers: '.implode(',', $allowedHeaders));
    if ($allowCredentials) {
      header('Access-Control-Allow-Credentials: true');
    }
  }
}
```

Its responsibilities include:

- Loading environment variables
- Initializing configuration and database
- Resolving routes
- Dispatching controllers
- Sending the final response

This is effectively the kernel of the framework.

#### 2.6.1. Config File

Create a `config.php` file in the `app` directory.

```php title="app/config.php"
<?php

return [
  'app' => [
    'name' => getenv('APP_NAME') ?: '',
    'description' => getenv('APP_DESCRIPTION') ?: '',
    'env' => getenv('APP_ENV') ?: 'development',
    'url' => getenv('APP_URL') ?: '',
    'viteUrl' => 'http://[::1]:5173',
  ],

  'cors' => [
    'allowed_origins' => explode(',', getenv('CORS_ALLOWED_ORIGINS') ?: '*'),
    'allowed_methods' => explode(',', getenv('CORS_ALLOWED_METHODS') ?: ''),
    'allowed_headers' => explode(',', getenv('CORS_ALLOWED_HEADERS') ?: ''),
    'allow_credentials' => filter_var(getenv('CORS_ALLOW_CREDENTIALS') ?: 'false', FILTER_VALIDATE_BOOLEAN),
  ],

  'database' => [
    'driver' => 'mysql',
    'host' => getenv('MYSQL_HOST') ?: '127.0.0.1',
    'port' => getenv('MYSQL_PORT') ?: '3306',
    'name' => getenv('MYSQL_DATABASE') ?: 'mizuki',
    'user' => getenv('MYSQL_USER') ?: 'root',
    'password' => getenv('MYSQL_PASSWORD') ?: '',
  ],
];
```

#### 2.6.2. Helpers functions

Create a `helpers.php` file for utility functions.

```php title="src/helpers.php"
<?php

function createId(): string {
  $timestamp = base_convert((string) floor(microtime(true) * 1000), 10, 36);
  $random = substr(bin2hex(random_bytes(8)), 0, 23 - strlen($timestamp));

  return 'c'.str_pad($timestamp, 8, '0', STR_PAD_LEFT).$random;
}

function getConfig() {
  $configPath = dirname(__DIR__).'/app/config.php';
  if (!file_exists($configPath)) {
    throw new Exception("Configuration file not found at {$configPath}");
  }

  return require $configPath;
}

function vite_entry_client() {
  $config = getConfig();
  if ('production' === $config['app']['env']) {
    return '';
  }

  return '<script type="module" src="'.$config['app']['viteUrl'].'/@vite/client"></script>';
}

function vite_entry_script(string $entryName, string $ext = 'ts'): string {
  $config = getConfig();

  $jsPath = $config['app']['viteUrl'].'/resources/js/'.$entryName.'.'.$ext;
  if ('production' === $config['app']['env']) {
    $manifest = getManifest();
    $jsPath = '/build/'.$manifest['resources/js/'.$entryName]['file'];
  }

  return '<script type="module" src="'.$jsPath.'"></script>';
}

function vite_entry_link(string $entryName, string $ext = 'css'): string {
  $config = getConfig();

  $cssPath = $config['app']['viteUrl'].'/resources/css/'.$entryName.'.'.$ext;
  if ('production' === $config['app']['env']) {
    $manifest = getManifest();
    $cssPath = '/build/'.$manifest['resources/js/'.$entryName]['css'][0];
  }

  return '<link rel="stylesheet" href="'.$cssPath.'">';
}

function getManifest(): array {
  $manifestPath = dirname(__DIR__).'/public/build/.vite/manifest.json';
  if (!file_exists($manifestPath)) {
    throw new Exception("Vite manifest file not found at {$manifestPath}");
  }

  $manifest = json_decode(file_get_contents($manifestPath), true);
  $newManifest = [];
  foreach ($manifest as $key => $value) {
    $newManifest[preg_replace('/\.[^.\/]+$/', '', $key)] = $value;
  }

  return $newManifest;
}
```

#### 2.6.3. Config `Vite`

Create a `vite.config.ts` file in the root directory.

```ts title="vite.config.ts"
import { defineConfig } from 'vite'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
  plugins: [tailwindcss()],

  build: {
    outDir: 'public/build',
    copyPublicDir: false,
    manifest: true,
    rollupOptions: {
      input: { main: 'resources/js/main.ts' },
    },
  },
})
```

## 3. Defining Routes and Controllers

Routes act as the map of your application: they determine how incoming HTTP requests (like visiting `/`, `/about`, or `/user/123`) are dispatched to controllers or closures. In our framework, the Router listens to the request’s URI and method (GET, POST, etc.) and matches it with the defined routes.

### 3.1. Defining Controllers and Routes

Controllers are PHP classes that handle request logic. Our `HomeController` is a simple example:

```php title="app/Controllers/HomeController.php"
<?php
namespace App\Controller;

use Core\Abstract\Controller;
use Core\Http\Response;

class HomeController extends Controller
{
  public function index(): Response {
    return $this->render('home/index', [
      'title' => 'Home Page',
    ]);
  }
}
```

The `app/routes.php` file is where you register your routes:

```php title="app/routes.php"
<?php

use Core\Kernel\Router;

Router::get('/', [App\Controller\HomeController::class, 'index']);

Router::get('/user/:id', function ($id) {
  return "User ID: {$id}";
});
```

- `/` → Calls `HomeController@index`
- `/user/:id` → Demonstrates dynamic route parameters (e.g. /user/42)

### 3.2. Client-side Assets with Vite & Tailwind

To give your PHP framework a modern look and feel, you’ll want to add some client-side assets—namely CSS and JavaScript. We’ll use [Vite](https://vitejs.dev/) for lightning-fast development and [Tailwind CSS](https://tailwindcss.com/) for utility-first styling.

First, create your main JavaScript entry point:

```ts title="resources/js/main.ts"
import '../css/main.css'
```

This imports your main stylesheet, which will be processed by Vite.

Next, set up your main CSS file to use Tailwind and enable automatic class scanning for your PHP views:

```css title="resources/css/main.css"
@import 'tailwindcss';
@source "../views/**/*.php";
```

The `@import "tailwindcss";` line brings in Tailwind’s utilities, while `@source` tells Tailwind where to look for class names in your PHP view files, ensuring unused styles are purged in production.

Now, update your main layout to include the necessary asset links and scripts. This layout will be used by all your views:

```php title="resources/views/layouts/main.php"
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">

    <!-- SEO -->
    <title><?php
      if (isset($title) && $title) {
        echo $title.' | '.getConfig()['app']['name'];
      } else {
        echo getConfig()['app']['name'];
      }
    ?></title>
    <meta name="description" content="<?php
      if (isset($meta_description) && $meta_description) {
        echo $meta_description;
      } else {
        echo getConfig()['app']['description'];
      }
    ?>">

    <!-- fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">

    <!-- vite -->
    <?= vite_entry_client(); ?>
    <?= vite_entry_script('main'); ?>
    <?= vite_entry_link('main'); ?>
  </head>

  <body class="flex flex-col min-h-dvh antialiased font-sans">
    <?= $content; ?>
  </body>
</html>
```

Finally, create a simple home view to test your setup:

```php title="resources/views/app/home/index.php"
<main>
  <h1 class="text-4xl font-bold text-center mt-10">Welcome to My PHP Framework!</h1>
</main>
```

## 4. Bootstrapping the Application

Bootstrapping is the process of preparing and loading everything your application needs before it can handle a request. In modern PHP frameworks, this means setting up autoloaders, loading environment variables, initializing configuration, starting sessions, and wiring up dependencies.

Let’s break down what happens in the `public/index.php` file—our application’s entry point:

```php title="public/index.php"
<?php

declare(strict_types=1);

$basePath = dirname(__DIR__);

require_once $basePath.'/vendor/autoload.php';
require_once $basePath.'/src/helpers.php';

session_start();
$application = new Core\Application($basePath);
$application->register(function (Core\Kernel\Container $container) {
  $container->bind(
    App\Contract\Repository\IPostRepository::class,
    App\Repository\PostRepository::class
  );
})->run();
```

Now, start the built-in PHP server for testing:

```bash
bunx --bun concurrently --prefix-colors=\"#646CFF,#777BB4\" \"vite\" \"php -S localhost:8000 -t public\" --names \"VITE,PHP\"
```

You can now visit `http://localhost:8000` in your browser to see your minimal PHP framework in action!

## 5. Conclusion

You’ve just built a minimal PHP framework that covers the essentials:

- Request/response handling
- Routing
- Controllers
- Dependency injection
- Application bootstrapping

From here, you can extend it with middleware, authentication, ORM layers, caching, or CLI tooling. Full source code available on [GitHub](https://github.com/tiesen243/mizuki)

### 5.1. Where to Go Next

Building your own framework is a powerful way to demystify how tools like Laravel, Symfony, or Slim work under the hood. Now that you have a working foundation, here are some ideas for taking your framework further:

- **Middleware:** Add support for middleware to handle cross-cutting concerns like authentication, logging, or CORS. Middleware can be implemented as a stack that wraps around your controllers.
- **Advanced Routing:** Implement route groups, named routes, or route model binding for more flexibility and maintainability.
- **Template Engine:** Integrate a template engine like Twig or Blade for more expressive and reusable views.
- **Validation:** Add a validation layer for incoming requests to ensure data integrity and provide user-friendly error messages.
- **Authentication & Authorization:** Build a simple authentication system (login, registration, sessions) and add role-based access control.
- **ORM Integration:** Replace raw PDO with an ORM like Eloquent or Doctrine to simplify database interactions and migrations.
- **Testing:** Set up PHPUnit and write tests for your controllers, models, and routes to ensure your framework is robust and maintainable.
- **CLI Tooling:** Create a CLI tool (using Symfony Console or similar) for tasks like migrations, seeding, or scaffolding new components.
- **Error Handling:** Implement a global error handler and custom exception classes for better debugging and user feedback.
- **Configuration Management:** Support multiple environments (development, staging, production) and environment-specific configuration files.
- **API Support:** Add helpers for building RESTful APIs, including JSON responses, API versioning, and rate limiting.

### 5.2. Final Thoughts

By understanding and building each piece yourself, you gain a much deeper appreciation for the design decisions and trade-offs in popular frameworks. Even if you never use your own framework in production, this exercise will make you a better, more confident PHP developer.
