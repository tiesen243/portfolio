---
title: Build Your Own PHP Framework
description: Learn how to create a minimal PHP framework from scratch, covering routing, controllers, dependency injection, error handling, and application bootstrapping.
tags:
  - PHP
  - Framework
  - Web Development
  - Programming
publishedAt: 2025-12-28
---

Most developers rely on frameworks like Laravel or Symfony, but have you ever wondered how they actually work under the hood?

In this guide, we’ll walk step by step through building a minimal PHP framework from scratch. You’ll learn the fundamentals of:

- Handling requests and responses
- Defining routes
- Creating controllers
- Managing templates
- Bootstrapping the application

By the end, you’ll have a working, lightweight foundation that you can extend into your own framework.

## Setting Up the Project

Create a new directory and initialize Composer:

```bash
mkdir my-php-framework
cd my-php-framework
composer init
```

For convenience in development, install:

```package-install
-d vite tailwindcss @tailwindcss/vite
```

Update `composer.json` with autoloading and scripts:

```json title="composer.json"
{
  // ...other composer.json settings...
  "autoload": {
    "psr-4": {
      "App\\": "app/",
      "Core\\": "src/"
    }
  },
}
```

Install dependencies:

```bash
composer install
```

Now create this structure:

```text
.
├── app
│   ├── Contract
│   ├── Controller
│   ├── Entity
│   ├── Repository
│   ├── config.php
│   └── routes.php
├── migrations
├── public
│   ├── favicon.ico
│   └── index.php
├── resources
│   ├── css
│   ├── js
│   └── views
├── src
│   ├── Abstract
│   ├── Attribute
│   ├── Http
│   ├── Kernel
│   ├── Application.php
│   └── helpers.php
├── bun.lock
├── composer.json
├── composer.lock
├── docker-compose.yml
├── Dockerfile
├── LICENSE
├── package.json
├── README.md
└── vite.config.ts
```

## Building the Framework

### Handling Requests and Responses

The request/response cycle is the heart of any framework.

- `Request` wraps superglobals (`$_SERVER`, `$_GET`, `$\_POST, etc.)
- `Response` handles status codes, headers, and output

1. Create a `Request` class to encapsulate HTTP request data.

```php title="src/Http/Request.php"
<?php

declare(strict_types=1);

namespace Core\Http;

class Request
{
  private array $get;
  private array $post;
  private array $server;

  public function __construct(array $get = [], array $post = [], array $server = []) {
    $this->get = !empty($get) ? $get : $_GET;
    $this->post = !empty($post) ? $post : $_POST;
    $this->server = !empty($server) ? $server : $_SERVER;
  }

  public function method(): string {
    return $this->server['REQUEST_METHOD'] ?? 'GET';
  }

  public function uri(): string {
    return $this->server['REQUEST_URI'] ?? '/';
  }

  public function getQuery(string $key, $default = null) {
    return $this->get[$key] ?? $default;
  }

  public function getPost(string $key, $default = null) {
    return $this->post[$key] ?? $default;
  }

  public function getArgv(int $index, $default = null) {
    $argv = $this->server['argv'] ?? [];

    return $argv[$index] ?? $default;
  }
}
```

2. Create a `Response` class to manage HTTP responses.

```php title="src/Http/Response.php"
<?php

declare(strict_types=1);

namespace Core\Http;

class Response
{
  public function __construct(
    private string $body = '',
    private int $statusCode = 200,
    private array $headers = [],
  ) {
  }

  public function send(): void {
    http_response_code($this->statusCode);
    foreach ($this->headers as $key => $value) {
      header("{$key}: {$value}");
    }
    echo $this->body;
  }

  public static function json(array $data, int $statusCode = 200, array $headers = []): self {
    $headers['Content-Type'] = 'application/json';
    $body = json_encode($data);

    return new self($body, $statusCode, $headers);
  }

  public static function redirect(string $url, int $statusCode = 302, array $headers = []): self {
    $headers['Location'] = $url;

    return new self('', $statusCode, $headers);
  }
}
```

### Implementing Controllers

Create a base `Controller` class that other controllers will extend.

```php title="src/Abstract/Controller.php"
<?php

declare(strict_types=1);

namespace Core\Abstract;

use App\Entity\User;
use Core\Http\{Request, Response};
use Core\Kernel\Database;

abstract class Controller
{
  protected \PDO $db;

  public function __construct(protected Request $request, private string $basePath) {
    $this->db = Database::getInstance();
  }

  protected function render(string $view, array $data = [], string $layout = 'main'): Response {
    if (isset($_SESSION['redirect_data'])) {
      $data = array_merge($data, $_SESSION['redirect_data']);
      unset($_SESSION['redirect_data']);
    }

    if (!file_exists($this->basePath.'/resources/views/app/'.$view.'.php')) {
      return new Response('View not found: '.$view, 400);
    }

    ob_start();
    extract($data);
    $flash = $this->getFlash();
    require $this->basePath.'/resources/views/app/'.$view.'.php';
    $content = ob_get_clean();

    ob_start();
    require $this->basePath.'/resources/views/layouts/'.$layout.'.php';
    $content = ob_get_clean();

    return new Response($content);
  }

  protected function json(array $data): Response {
    $response = Response::json($data);

    return $response;
  }

  protected function redirect(string $url, array $data = []): Response {
    if (!empty($data)) {
      $_SESSION['redirect_data'] = $data;
    }
    $response = Response::redirect($url);

    return $response;
  }

  protected function getFlash(): ?array {
    if (isset($_SESSION['flash'])) {
      $flash = $_SESSION['flash'];
      unset($_SESSION['flash']);

      return $flash;
    }

    return null;
  }

  /**
   * @param "default"|"success"|"error"|"info"|"warn" $type
   */
  protected function setFlash(string $type = 'default', string $message = ''): void {
    $_SESSION['flash'] = [
      'type' => $type,
      'message' => $message,
    ];
  }

  protected function isAuthenticated(): bool {
    return isset($_SESSION['user']);
  }

  protected function getUser(): ?User {
    return $_SESSION['user'] ?? null;
  }
}
```

### Implementing Router

Create a `Router` class to handle routing logic.

```php title="src/Kernel/Router.php"
<?php

declare(strict_types=1);

namespace Core\Kernel;

class Router
{
  private static $routes = [];

  /**
   * Register a GET route.
   *
   * @param callable|array $handler Handler function or [Controller, method]
   */
  public static function get(string $path, callable|array $handler): self {
    self::addRoute('GET', $path, $handler);

    return new self();
  }

  /**
   * Register a POST route.
   *
   * @param string         $path
   * @param callable|array $handler Handler function or [Controller, method]
   */
  public static function post($path, $handler): self {
    self::addRoute('POST', $path, $handler);

    return new self();
  }

  private static function addRoute($method, $path, $handler) {
    self::$routes[$method][$path] = $handler;
  }

  public static function getRoutes(): array {
    return self::$routes;
  }
}
```

### Implementing Database Connection

Create a simple database connection class using PDO.

```php title="src/Kernel/Database.php"
<?php

declare(strict_types=1);

namespace Core\Kernel;

class Database
{
  private static $instance;
  private \PDO $connection;

  private function __construct(array $config) {
    $dsn = "{$config['driver']}:host={$config['host']};port={$config['port']};dbname={$config['name']};charset=utf8mb4";
    $this->connection = new \PDO($dsn, $config['user'], $config['password']);
    $this->connection->setAttribute(\PDO::ATTR_ERRMODE, \PDO::ERRMODE_EXCEPTION);
  }

  public static function connect(array $config): static {
    if (null === self::$instance) {
      self::$instance = new self($config);
    }

    return self::$instance;
  }

  public static function getInstance(): \PDO {
    if (null === self::$instance) {
      throw new \Exception('Database instance not created. Call createInstance() first.');
    }

    return self::$instance->connection;
  }
}
```

### Container for Dependency Injection

Create a simple service container for managing dependencies.

```php title="src/Kernel/Container.php"
<?php

declare(strict_types=1);

namespace Core\Kernel;

class Container
{
  protected array $bindings = [];

  public function bind(string $abstract, string $concrete): void {
    $this->bindings[$abstract] = $concrete;
  }

  public function make(string $class, array $parameters = []) {
    if (isset($this->bindings[$class])) {
      $class = $this->bindings[$class];
    }

    $reflector = new \ReflectionClass($class);

    if (!$reflector->isInstantiable()) {
      throw new \Exception("Class {$class} is not instantiable");
    }

    $constructor = $reflector->getConstructor();

    if (!$constructor) {
      return new $class();
    }

    $params = $constructor->getParameters();
    $dependencies = $this->resolveParameters($params, $parameters);

    return $reflector->newInstanceArgs($dependencies);
  }

  public function call($instance, string $method, array $manual = []) {
    $reflector = new \ReflectionMethod($instance, $method);
    $params = $reflector->getParameters();
    $dependencies = $this->resolveParameters($params, $manual);

    return $reflector->invokeArgs($instance, $dependencies);
  }

  protected function resolveParameters(array $params, array $manual = []): array {
    $resolved = [];

    foreach ($params as $param) {
      $type = $param->getType();
      $name = $param->getName();

      if ($type && !$type->isBuiltin()) {
        $resolved[] = $this->make($type->getName());
      } elseif (isset($manual[$name])) {
        $resolved[] = $manual[$name];
      } elseif ($param->isDefaultValueAvailable()) {
        $resolved[] = $param->getDefaultValue();
      } else {
        throw new \Exception("Cannot resolve parameter {$name}");
      }
    }

    return $resolved;
  }
}
```

### Application Bootstrapping Helper

Create an `Application` class to bootstrap the framework.

```php title="src/Application.php"
<?php

declare(strict_types=1);

namespace Core;

use Core\Http\{Request,Response};
use Core\Kernel\{Container, Database, Router};

class Application
{
  private string $basePath;
  private array $config;

  protected Container $container;
  protected Request $request;

  public function __construct(string $basePath) {
    $this->basePath = rtrim($basePath, '/');

    $this->loadEnv();
    $this->config = getConfig();
    Database::connect($this->config['database']);
  }

  public function register(callable $callback): self {
    $this->container = new Container();
    call_user_func($callback, $this->container);

    return $this;
  }

  public function run(): void {
    require_once $this->basePath.'/app/routes.php';

    $this->request = new Request($_GET, $_POST, $_SERVER);
    $routes = Router::getRoutes();

    $method = $this->request->method();
    $uri = parse_url($this->request->uri(), PHP_URL_PATH);
    if ('/' !== $uri && '/' === substr($uri, -1)) {
      $uri = rtrim($uri, '/');
    }

    if (isset($routes[$method][$uri])) {
      $response = $this->dispatch($routes[$method][$uri]);
    } else {
      foreach ($routes[$method] as $routePattern => $handler) {
        $pattern = preg_replace('#:([\w]+)#', '(?P<$1>[^/]+)', $routePattern);
        $pattern = '#^'.$pattern.'$#';
        if (preg_match($pattern, $uri, $matches)) {
          $params = array_filter($matches, 'is_string', ARRAY_FILTER_USE_KEY);
          $response = $this->dispatch($handler, $params);
        }
      }
    }

    if (!$response instanceof Response) {
      $response = new Response($response);
    }
    $this->setCorsHeaders();
    $response->send();
  }

  private function dispatch(callable|array $handler, array $params = []): Response {
    $response = Response::json(['message' => 'Not Found'], 404);

    if (is_callable($handler)) {
      $response = call_user_func($handler, $this->request, ...array_values($params));
    } elseif (is_array($handler) && 2 === count($handler)) {
      if (!is_subclass_of($handler[0], Abstract\Controller::class)) {
        $response = Response::json(['message' => 'Controller Not Found'], 404);
      } else {
        $controller = $this->container->make($handler[0], [
          'request' => $this->request,
          'basePath' => $this->basePath,
        ]);

        if (!method_exists($controller, $handler[1])) {
          $response = Response::json(['message' => 'Method Not Found'], 404);
        } else {
          $response = $this->container->call($controller, $handler[1], $params);
        }
      }
    }

    return $response;
  }

  private function loadEnv(string $envPath = '.env'): void {
    $envFile = $this->basePath.DIRECTORY_SEPARATOR.$envPath;
    if (!file_exists($envFile)) {
      return;
    }

    $lines = file($envFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
    foreach ($lines as $line) {
      if (0 === strpos(trim($line), '#')) {
        continue;
      }
      list($key, $value) = explode('=', $line, 2);
      $key = trim($key);
      $value = trim($value, "\"'");
      if (!getenv($key)) {
        putenv("{$key}={$value}");
      }
    }
  }

  private function setCorsHeaders(): void {
    $corsConfig = $this->config['cors'] ?? [];
    $allowedOrigins = $corsConfig['allowed_origins'] ?? [];
    $allowedMethods = $corsConfig['allowed_methods'] ?? [];
    $allowedHeaders = $corsConfig['allowed_headers'] ?? [];
    $allowCredentials = $corsConfig['allow_credentials'] ?? false;

    header('Access-Control-Allow-Origin: '.implode(',', $allowedOrigins));
    header('Access-Control-Allow-Methods: '.implode(',', $allowedMethods));
    header('Access-Control-Allow-Headers: '.implode(',', $allowedHeaders));
    if ($allowCredentials) {
      header('Access-Control-Allow-Credentials: true');
    }
  }
}
```

#### Helpers functions

Create a `helpers.php` file for utility functions.

```php title="src/helpers.php"
<?php

function createId(): string {
  $timestamp = base_convert((string) floor(microtime(true) * 1000), 10, 36);
  $random = substr(bin2hex(random_bytes(8)), 0, 23 - strlen($timestamp));

  return 'c'.str_pad($timestamp, 8, '0', STR_PAD_LEFT).$random;
}

function getConfig() {
  $configPath = dirname(__DIR__).'/app/config.php';
  if (!file_exists($configPath)) {
    throw new Exception("Configuration file not found at {$configPath}");
  }

  return require $configPath;
}

function vite_entry_client() {
  $config = getConfig();
  if ('production' === $config['app']['env']) {
    return '';
  }

  return '<script type="module" src="'.$config['app']['viteUrl'].'/@vite/client"></script>';
}

function vite_entry_script(string $entryName, string $ext = 'ts'): string {
  $config = getConfig();

  $jsPath = $config['app']['viteUrl'].'/resources/js/'.$entryName.'.'.$ext;
  if ('production' === $config['app']['env']) {
    $manifest = getManifest();
    $jsPath = '/build/'.$manifest['resources/js/'.$entryName]['file'];
  }

  return '<script type="module" src="'.$jsPath.'"></script>';
}

function vite_entry_link(string $entryName, string $ext = 'css'): string {
  $config = getConfig();

  $cssPath = $config['app']['viteUrl'].'/resources/css/'.$entryName.'.'.$ext;
  if ('production' === $config['app']['env']) {
    $manifest = getManifest();
    $cssPath = '/build/'.$manifest['resources/js/'.$entryName]['css'][0];
  }

  return '<link rel="stylesheet" href="'.$cssPath.'">';
}

function getManifest(): array {
  $manifestPath = dirname(__DIR__).'/public/build/.vite/manifest.json';
  if (!file_exists($manifestPath)) {
    throw new Exception("Vite manifest file not found at {$manifestPath}");
  }

  $manifest = json_decode(file_get_contents($manifestPath), true);
  $newManifest = [];
  foreach ($manifest as $key => $value) {
    $newManifest[preg_replace('/\.[^.\/]+$/', '', $key)] = $value;
  }

  return $newManifest;
}
```

### Config `Vite` for Asset Management

Create a `vite.config.ts` file in the root directory.

```ts title="vite.config.ts"
import { defineConfig } from "vite";
import tailwindcss from "@tailwindcss/vite";

export default defineConfig({
  plugins: [tailwindcss()],

  build: {
    outDir: "public/build",
    copyPublicDir: false,
    manifest: true,
    rollupOptions: {
      input: { main: "resources/js/main.ts" },
    },
  },
});
```

## Defining Routes

Routes act as the map of your application: they determine how incoming HTTP requests (like visiting `/`, `/about`, or `/user/123`) are dispatched to controllers or closures. In our framework, the Router listens to the request’s URI and method (GET, POST, etc.) and matches it with the defined routes.

### Controller Example

Controllers are PHP classes that handle request logic.
Our `HomeController` is a simple example:

```php title="app/Controllers/HomeController.php"
<?php
namespace App\Controller;

use Core\Abstract\Controller;
use Core\Http\Response;

class HomeController extends Controller
{
  public function index(): Response {
    return $this->render('home/index', [
      'title' => 'Home Page',
    ]);
  }
}
```

Instead of echoing HTML directly, controllers return a view, which the framework renders.

### Registering Routes

The `routes/web.php` file is where you register your routes:

```php title="app/routes.php"
<?php

use Core\Kernel\Router;

Router::get('/', [App\Controller\HomeController::class, 'index']);

Router::get('/user/:id', function ($id) {
  return "User ID: {$id}";
});
```

- `/` → Calls `HomeController@index`
- `/user/:id` → Demonstrates dynamic route parameters (e.g. /user/42)

## Bootstrapping the Application

Finally, the `public/index.php` file is our entry point. It loads environment variables, initializes the application, and runs the request/response cycle:

```php title="public/index.php"
<?php

declare(strict_types=1);

$basePath = dirname(__DIR__);

require_once $basePath.'/vendor/autoload.php';
require_once $basePath.'/src/helpers.php';

session_start();
$application = new Core\Application($basePath);
$application->register(function (Core\Kernel\Container $container) {
  $container->bind(
    App\Contract\Repository\IPostRepository::class,
    App\Repository\PostRepository::class
  );
  $container->bind(
    App\Contract\Repository\IUserRepository::class,
    App\Repository\UserRepository::class
  );
})->run();
```

## Conclusion

And there you have it! A minimal PHP framework that covers the essentials: routing, controllers, dependency injection, error handling, and application bootstrapping. From here, you can expand this foundation by adding features like middleware, authentication, database ORM, caching, and more.
Feel free to explore the complete code on [GitHub](https://github.com/tiesen243/mizuki)
